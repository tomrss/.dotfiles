#+title: Emacs Configuration
#+author: Tommaso Rossi
#+property: header-args:emacs-lisp :tangle .emacs.d/init.el :mkdirp yes

Literate configuration for GNU Emacs.

Main features:
- Optimization of startup times with careful lazy loading.
- Reproducible builds with =straight.el=.
- Completion framework including completions at point and minibuffer completions
  with incremental narrowing, fuzzy matching of results and frequency-recency based ordering
  of completion candidates.
- Enhancements of Emacs terminals, with special attention to =eshell=.
- Non-intrusive vim-like (=evil=) keybindings.  Keybindings in this configuration are the Emacs
  defaults, eccept for the ones set by =evil= and =evil-collection=.  No further customization
  is performed for ensuring understandability.
- Development with LSP mode where feasible.
- Configuration of some frontends for external applications to ensure an immersive Emacs experience.
- Optional configuration of =EXWM=, the Emacs window manager for Xorg (see =Desktop.org=).

Note: sometimes I found clearer to read directly the tangled source instead of the Org file.
That's why comments are tangled in source too.

* Early init

The early init file is loaded before the =init.el= file.  Is loaded even before the GUI is
initialized.
https://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html

** Header

Header of the early init file:

#+begin_src emacs-lisp :tangle .emacs.d/early-init.el :mkdirp yes
  ;;; early-init.el --- Emacs early init -*- lexical-binding: t -*-

  ;; Copyright (C) 2021 Tommaso Rossi

  ;; Author: Tommaso Rossi <tommaso.rossi1@protonmail.com

  ;; This file is NOT part of GNU Emacs.

  ;;; Commentary:

  ;; Emacs early init file, that gets evaluated before init.el and even before the GUI is loaded.
  ;; The focus is on optimizing startup time and perform basic UI cleanups.

  ;;; Code:
#+end_src

** Garbage collections

Improve startup time by reducing garbage collections at startup.  The classic strategy is to set a high consing threshold during initialization and then restore it to a lower value once init is completed.

#+begin_src emacs-lisp :tangle .emacs.d/early-init.el :mkdirp yes

  ;;;; Optimize garbage collections

  (defconst tr/gc-cons-standard-threshold-mb 1024
    "Number of MB of consing between garbage collection during normal operativity.")
  (defconst tr/gc-cons-startup-threshold-mb 2048
    "Number of MB of consing between garbage collection during startup.")

  (defun tr/restore-garbage-collection ()
    "Restore GC consing threshold to `tr/gc-cons-standard-threshold-mb'."
    (setq gc-cons-threshold (* tr/gc-cons-standard-threshold-mb 1024 1024)))

  ;; set high garbage collection consing threshold during startup
  (setq gc-cons-threshold (* tr/gc-cons-startup-threshold-mb 1024 1024))

  ;; restore garbage collection after init
  (add-hook 'after-init-hook 'tr/restore-garbage-collection)

#+end_src

Another useful trick is to garbage collect when idle (from https://emacs.stackexchange.com/questions/34342/is-there-any-downside-to-setting-gc-cons-threshold-very-high-and-collecting-ga)

#+begin_src emacs-lisp :tangle .emacs.d/early-init.el :mkdirp yes
  ;; garbage collect when idle
  (run-with-idle-timer 2 t 'garbage-collect)

#+end_src

** File name handlers at startup

Temporarily disabling file name handlers at startup can speedup startup too.  Source: ambrevar dotfiles https://github.com/Ambrevar/dotfiles/blob/master/.emacs.d/init.el

#+begin_src emacs-lisp :tangle .emacs.d/early-init.el :mkdirp yes
  ;;;; Temporary disable file handler at startup

  (defvar default-file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)

  (defun tr/reset-file-name-handler-alist ()
    "Reset filename handlers to default value."
    (setq file-name-handler-alist default-file-name-handler-alist))

  (add-hook 'after-init-hook 'tr/reset-file-name-handler-alist)

#+end_src

** Disable =package.el=

Disable =package.el= at startup as =straight.el= package manager will be used.

#+begin_src emacs-lisp :tangle .emacs.d/early-init.el :mkdirp yes
  ;;;; Disable package.el at startup

  (setq package-enable-at-startup nil)

#+end_src

** Early UI cleanups

Remove useless stuff from UI and other optimizations

#+begin_src emacs-lisp :tangle .emacs.d/early-init.el :mkdirp yes
  ;;;; Early UI cleanups

  ;; frame resize seems to be very expensive, disable it
  (setq frame-inhibit-implied-resize t)
  (setq inhibit-default-init t)
  (setq inhibit-startup-buffer-menu t)
  (setq inhibit-startup-screen t)
  (setq initial-scratch-message nil)
  (setq initial-major-mode 'fundamental-mode)

#+end_src

** Move backups elsewhere

#+begin_src emacs-lisp :tangle .emacs.d/early-init.el :mkdirp yes
  ;;;; Move backups elsewhere

  (setq default-directory "~/")
  (setq backup-directory-alist `(("." . "~/.cache/emacs/var/backup/")))

#+end_src

** Footer

Footer of the early init file:

#+begin_src emacs-lisp :tangle .emacs.d/early-init.el :mkdirp yes
  ;;; early-init.el ends here
#+end_src

* Header

Header of the init file:

#+begin_src emacs-lisp
  ;;; init.el --- Emacs configuration -*- lexical-binding: t -*-

  ;; Copyright (C) 2021 Tommaso Rossi

  ;; Author: Tommaso Rossi <tommaso.rossi1@protonmail.com

  ;; This file is NOT part of GNU Emacs.

  ;;; Commentary:

  ;; GNU Emacs configuration.

  ;; Main features:

  ;; - Optimization of startup times with careful lazy loading.
  ;; - Reproducible builds with =straight.el=.
  ;; - Completion framework including completions at point (`company')
  ;;   and minibuffer completions with incremental narrowing, fuzzy matching
  ;;   of results and frequency-recency based ordering of completion candidates.
  ;; - Enhancements of Emacs terminals, with special attention to =eshell=.
  ;; - Non-intrusive vim-like (`evil') keybindings.  Keybindings in this config
  ;;   are the Emacs defaults, eccept for the ones set by `evil' and `evil-collection'.
  ;;   No further customization is performed for ensuring understandability.
  ;; - Development with LSP mode where feasible.
  ;; - Configuration of some frontends for external applications to ensure an
  ;;   immersive Emacs experience.
  ;; - Optional configuration of =EXWM=, the Emacs window manager for Xorg
  ;;   (see `desktop.el').

  ;;; Code:

#+end_src

* Some early configuration

Display startup time in seconds to better monitoring.

#+begin_src emacs-lisp
  ;;;; Measure init time
  
  (defconst emacs-start-time (current-time))
  
  (add-hook 'after-init-hook
	    `(lambda ()
	       (let ((elapsed
		      (float-time
		       (time-subtract (current-time) emacs-start-time))))
		 (message "Initialized in %.2fs with %d garbage collections" elapsed gcs-done))) t)
  
#+end_src

Disable menus and some mouse-based interface.

#+begin_src emacs-lisp
  ;; disable really ugly stuff
  (menu-bar-mode -1)
  (toggle-scroll-bar -1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)

#+end_src

The following is a dirty trick to avoid the annoying startup message:
#+begin_quote
For information about GNU Emacs and the GNU system, type C-h C-a.
#+end_quote
The only way to disable is having your username /hardcoded/ in the =init.el=: Emacs analyzes statically the init file for finding this row:
#+begin_quote
(setq inhibit-startup-echo-area-message "your-username-here")
#+end_quote
So there's no way to do it in Emacs Lisp code, but org mode can help:

#+name: whoami
#+begin_src shell :results output
  # use echo -n for stripping away the newline
  echo -n $(whoami)
#+end_src

#+begin_src emacs-lisp :noweb yes
  (setq inhibit-startup-echo-area-message "<<whoami()>>")
    
#+end_src

Put native compilation warnings in a background buffer.  If native compilation feature is not used,
this =setq= should not bother.

#+begin_src emacs-lisp
  ;; silent native compilation warning
  (setq native-comp-async-report-warnings-errors 'silent)

#+end_src

Start fullscreen.

#+begin_src emacs-lisp
  ;; start fullscreen
  (add-to-list 'default-frame-alist '(fullscreen . maximized))

#+end_src

Add the custom lisp folder to load path.

#+begin_src emacs-lisp
  ;; add lisp folder to load path
  (eval-when-compile
    (add-to-list 'load-path "~/.emacs.d/lisp/"))

#+end_src

* Packaging

This section is dedicated to configuring the package manager (=straight.el=) and the main packaging
helper macro (=use-package=) to pull and configure packages used in this configuration.
This section *should* (eccept for some =:straight= directive in =use-package= forms) the only one to be modified if another package manager is used.

#+begin_src emacs-lisp
  ;;;; packaging

#+end_src

** Bootstrap the package manager

The =straight.el= package manager is preferred to the builtin =package.el= due to its "functional package manager" pattern that ensures reproducible builds and facilitate interacting and modifying packages, as they are pulled as git repositories and not just opaque tarballs.

https://github.com/raxod502/straight.el

#+begin_src emacs-lisp
  ;;;;; Configure `straight.el' as package manager

  ;; bootstrap `straight.el'
  (defvar bootstrap-version)
  (let ((bootstrap-file
	 (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	(bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
	  (url-retrieve-synchronously
	   "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	   'silent 'inhibit-cookies)
	(goto-char (point-max))
	(eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

** Manage lockfile and profiles

Multiple profiles can be managed by =straight.el=, but here just the default one will be used.
To ensure *exact* reproducibility I keep the lockfile checked into source control
(see https://github.com/raxod502/straight.el#lockfile-management).

#+begin_src emacs-lisp
  ;; configure straight lockfile (it can be committed)
  (setq straight-profiles '((nil . "~/.emacs.d/lockfile.el")))

#+end_src

** Initialize =use-package=

=use-package= is a widely used macro that helps keeping the configuration clean.
https://github.com/jwiegley/use-package

#+begin_src emacs-lisp
  ;;;;; Configure `use-package'

  ;; pull use-package
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)

  ;; do not break if some :ensure are still in `use-package' forms
  (setq use-package-ensure-function
	(lambda (name &rest _)
	  (message "Ignoring ':ensure t' in '%s' config" name)))

  ;; uncomment for enabling package auditing:
  ;; (setq use-package-verbose t)
  ;; (setq use-package-compute-statistics t)

#+end_src

* Keep folders clean

By default Emacs spams ~ (backups) and # (lock) files everywhere.
More precisely, in the same folder of edited file.  As already stated, this behaviour is not acceptable as it pollutes the filesystem.

For starters, disable lockfiles.
#+begin_src emacs-lisp
  ;;;;; Keep folders clean

  ;; disable pesky lockfiles
  (setq create-lockfiles nil)

#+end_src

Change some backup defaults:

#+begin_src emacs-lisp
  ;; change some backup default
  (setq backup-by-copying t)
  (setq delete-old-versions t)
  (setq kept-new-versions 4)
  (setq kept-old-versions 2)
  (setq version-control t)

#+end_src

Another thing that is annoying if you have a configuration checked into source control is
the custom file: just put it in a temp file (cfr. ambrevar).  *Warning*: this actually disable
=customize= (as wanted).

#+begin_src emacs-lisp
  ;; custom file to temp file (practically disable `customize')
  (setq custom-file
	(if (boundp 'server-socket-dir)
	    (expand-file-name "custom.el" server-socket-dir)
	  (expand-file-name (format "emacs-custom-%s.el" (user-uid))
			    temporary-file-directory)))

#+end_src

* Completion framework

This section is dedicated to configuring a completion framework, entspanning completions at point
and minibuffer completions with incremental narrowing and smart ordering of completion candidates.
Getting help and hints is an important part of a completion framework too.

#+begin_src emacs-lisp
  ;;;; Completion framework

#+end_src

** Getting help and docs

Emacs describes itself as (see the Emacs =info= page):

#+begin_quote
Emacs is the advanced, extensible, customizable, self-documenting editor.
#+end_quote

As we can see, the self-documentation is a very important feature of Emacs, widely used both during
configuration and daily usage.  Some packages can greatly improve the self-documentation and getting help when needed.

#+begin_src emacs-lisp
  ;;;;; Getting help and docs

#+end_src

*** Improve self-documentation

The excellent =helpful= package expands self-documentation, adding useful contextual information
such as source snippets, links, and usages.

https://github.com/Wilfred/helpful

#+begin_src emacs-lisp
  ;; improve self documentation
  (use-package helpful
    :bind
    ([remap describe-function] . helpful-callable)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . helpful-variable)
    ([remap describe-key] . helpful-key)
    ("C-h o" . helpful-symbol)
    ("C-c C-d" . helpful-at-point))

#+end_src

** Minibuffer completions

This section is dedicated to minibuffer completions, using the well-known stack of packages by
the excellent [[https://github.com/oantolin][Omar Antolin Camarena]] and [[https://github.com/minad][Daniel Mendler]], two of the most active and prolific Emacs
packages developers lately.

These packages focus on minimalism and integration with the standard emacs API (completing read, completion styles, etc.) to ensure that each package does just one thing and can easily be replaced, in a full Unix fashioned way.

The packages are:

- =vertico=: VERTical Interactive COmpletion, by =minad=
- =marginalia=: Marginalia in the minibuffer, by =minad=
- =orderless=: Emacs completion style that matches multiple regexps in any order, by =oantolin=
- =embark=: Emacs Mini-Buffer Actions Rooted in Keymaps, by =oantolin=
- =consult=: Consulting completing-read, by =minad=

  #+begin_src emacs-lisp
    ;;;;; Minibuffer completions

  #+end_src

*** Completion UI

Configure a vertical based minibuffer completion UI with the =vertico= package.

TODO: find a way to select first candidate with TAB

https://github.com/minad/vertico

#+begin_src emacs-lisp
  ;; completion UI
  (use-package vertico
    :bind (:map vertico-map
		("C-j" . vertico-next)
		("C-k" . vertico-previous)
		("C-f" . vertico-exit)
		:map minibuffer-local-map
		("M-h" . backward-kill-word))
    :custom
    (vertico-cycle t)
    :init
    (vertico-mode +1))
#+end_src

*** Completion styles

/Completion styles/ are "sets of criteria for matching minibuffer text to completion alternatives"
(from [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Completion-Styles.html][Emacs docs]]).  =orderless= is an highly flexible completion style.

#+begin_src emacs-lisp
  ;; builtin `savehist-mode' allows to persist orderless selections
  (use-package savehist
    :straight nil
    :init
    (setq history-length 20)
    (savehist-mode +1))

  (use-package orderless
    :init
    (setq orderless-matching-styles '(orderless-literal
				      orderless-initialism
				      orderless-regexp))
    (setq orderless-component-separator "[ +]+")
    (setq completion-styles '(orderless)))

#+end_src

*** Contextual info in minibuffer

=marginalia= is an *incredibly* useful package that adds invaluably helpful contextual information in minibuffer (docstrings, actual values of variables, preview of faces and more), saving a huge amount of time.  It has a cool name too.

From the =marginalia= readme:
#+begin_quote
Marginalia are marks or annotations placed at the margin of the page of a book or in this case helpful colorful annotations placed at the margin of the minibuffer for your completion candidates.
#+end_quote

https://github.com/minad/marginalia

#+begin_src emacs-lisp
  ;; get help and docs in minibuffer
  (use-package marginalia
    :bind
    (:map minibuffer-local-map
	  ("M-A" . marginalia-cycle))
    :init
    (marginalia-mode +1))

#+end_src

*** Completing read functions

The =consult= package provides very useful commands based on the =completing-read= interface and
integrates superbly well with the other packages used in this section.

https://github.com/minad/consult

TODO: this is almost literally copied from =consult= page, but many of this commands are seldom or never used.

#+begin_src emacs-lisp
  ;; add useful functions with consult
  (use-package consult
    :config
    (setq consult-narrow-key "<")
    :bind (;; C-c bindings (mode-specific-map)
	   ("C-c h" . consult-history)
	   ("C-c m" . consult-mode-command)
	   ("C-c b" . consult-bookmark)
	   ("C-c k" . consult-kmacro)
	   ;; C-x bindings (ctl-x-map)
	   ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complet-command
	   ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
	   ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
	   ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
	   ;; Other custom bindings
	   ("M-y" . consult-yank-pop)                ;; orig. yank-pop
	   ("C-x f" . consult-recent-file)           ;; orig. set-fill-column. requires recentf
	   ;; M-g bindings (goto-map)
	   ("M-g e" . consult-compile-error)
	   ("M-g g" . consult-goto-line)             ;; orig. goto-line
	   ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
	   ("M-g o" . consult-outline)
	   ("M-g m" . consult-mark)
	   ("M-g k" . consult-global-mark)
	   ("M-g i" . consult-imenu)
	   ("M-g I" . consult-imenu-multi)
	   ;; M-s bindings (search-map)
	   ("M-s f" . consult-find)
	   ("M-s L" . consult-locate)
	   ("M-s g" . consult-grep)
	   ("M-s G" . consult-git-grep)
	   ("M-s r" . consult-ripgrep)
	   ;; TODO consult line is great but for quick navigation isearch is too good to be replaced
	   ("C-s" . consult-line)
	   ("M-s m" . consult-multi-occur)
	   ("M-s k" . consult-keep-lines)
	   ("M-s u" . consult-focus-lines)
	   (:map minibuffer-local-map
		 ("C-r" . consult-history))))

#+end_src

Recognize =use-package= declaration in =imenu= (useful for narrowing with =consult-imenu=).

#+begin_src emacs-lisp
  (defun tr/add-use-package-to-imenu()
    "Add use-package declarations to imenu expressions."
    ;; TODO not the cleanest regex, but emacs regex hard wo weird...
    (add-to-list 'imenu-generic-expression '("Packages" "^\\s-*(use-package\\(?:-local\\)?\\s-+\\(\\(?:\\sw\\|\\s_\\|\\\\.\\)+\\)[[:space:]\n]+[^)]" 1)))

  (add-hook 'emacs-lisp-mode-hook #'tr/add-use-package-to-imenu)
 
#+end_src

*** Minibuffer actions

Modern text editors and IDEs often provide contextual menus (for example with right click).
We can get that functionality in Emacs, and much more, obviously without even rely on the mouse,
thanks to the =embark= package.  This package allows to perform actions on minibuffer completion candidates and enables apparently endless possibilities of workflows and integrations with other
packages, most notably =consult=.  See the =embark= README for some interesting examples.

#+begin_src emacs-lisp
  ;; enable acting on minibuffer candidates (and much more)
  (use-package embark
    :bind
    (("C-S-a" . embark-act)
     ("C-h B" . embark-bindings)
     (:map embark-symbol-map ("h" . helpful-symbol)))
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command))

  (use-package embark-consult
    :after (:all embark consult)
    :demand t
    :hook
    (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src

** Autocomplete in-buffer

Configure completions at point and snippets.

#+begin_src emacs-lisp
  ;;;;;  Autocomplete in-buffer

#+end_src

*** Completions in region

Completions in region with =corfu=.

#+begin_src emacs-lisp
  (use-package corfu
    :init
    (corfu-global-mode +1)
    :config
    (setq corfu-auto t)
    (setq corfu-auto-delay 0.1)
    (setq corfu-cycle t)
    ;; quit corfu popup on space, for using orderless fuzzy match use the "+":
    (setq corfu-quit-at-boundary t)
    (setq corfu-preselect-first t)
    (setq corfu-echo-documentation 0))

  (setq tab-always-indent 'complete)

#+end_src

*** Snippets

TODO: find a way to integrate with corfu
TODO: find out an acceptable workflow for yasnippet.  can't use it right now

=yasnippet= is used for getting code (and other) snippets as you write.

#+begin_src emacs-lisp
  ;; (use-package yasnippet
  ;;   :if (not noninteractive)
  ;;   :diminish yas-minor-mode
  ;;   :commands (yas-global-mode yas-minor-mode)
  ;;   :hook
  ;;   ((prog-mode . yas-minor-mode)
  ;;    (conf-mode . yas-minor-mode))
  ;;   :config
  ;;   ;; (add-to-list 'company-backends 'company-yasnippet)
  ;;   ;; disable TAB key for yasnippet, just rely on yas company backend
  ;;   (define-key yas-minor-mode-map (kbd "TAB") nil)
  ;;   (define-key yas-minor-mode-map (kbd "<tab>") nil)
  ;;   (yas-reload-all))

  ;; (use-package yasnippet-snippets
  ;;   :after yasnippet)

#+end_src

* User interface

This section is dedicated to user interface settings.

*Caveat*: I try to add some support for Windows and Mac.  Note that I don't use these operating systems and this config isn't tested on anything that is not a GNU/Linux distribution.
So it's very likely that it does not work!

#+begin_src emacs-lisp
  ;;;; User interface

  ;; recognize system
  (defconst IS-GNU     (eq system-type 'gnu/linux))
  (defconst IS-MAC     (eq system-type 'darwin))
  (defconst IS-WINDOWS (memq system-type '(cygwin windows-nt ms-dos)))

  ;; disable the really annoying bell
  (setq ring-bell-function 'ignore)

#+end_src

** Fonts and icons

Configure fonts and icons.

TODO: parameterize font height?

#+begin_src emacs-lisp
  ;;;;; Fonts

  (when window-system
    (when (x-list-fonts "JetBrains Mono")
      (set-face-attribute 'default     nil :font "JetBrains Mono" :height 110 :weight 'regular)
      (set-face-attribute 'fixed-pitch nil :font "JetBrains Mono" :height 110 :weight 'regular))
    (when (x-list-fonts "Cantarell")
      (set-face-attribute 'variable-pitch nil :font "Cantarell" :height 130 :weight 'regular)))

  (use-package all-the-icons
    :if window-system
    :init
    (unless (x-list-fonts "all-the-icons")
      (if IS-WINDOWS
	  ;; didn't bother to find a way to programmatically install fonts in Windows
	  (warn "Run M-x all-the-icons-install-fonts to download the fonts, then install them manually")
	;; install fonts
	(all-the-icons-install-fonts t))))

#+end_src

** Theme

Theme configuration.  =doom-themes= are really curated and well done.

#+begin_src emacs-lisp
  ;;;;; Theme
  
  (use-package doom-themes
    :if window-system
    :init
    (load-theme 'doom-nord t)
    (set-face-attribute 'font-lock-doc-face nil :foreground "#EBCB8B")
    (set-face-attribute 'shadow nil :foreground "#EBCB8B"))
  
#+end_src

** Modeline

Customize modeline.  Just use =doom-modeline= which is great and works perfectly out of the box.
The only downside is some performance overhead at startup.
Hide modeline will be used later for some modes.

#+begin_src emacs-lisp
  ;;;;; Modeline
  
  ;; minions is a package that hides minor modes and provides a menu for managing them
  (use-package minions
    :init (minions-mode +1))
  
  (use-package doom-modeline
    :if window-system
    :init (doom-modeline-mode +1))
  
  ;; some modes do not need modeline
  (use-package hide-mode-line
    :defer t
    :hook ((help-mode helpful-mode vterm-mode treemacs-mode) . hide-mode-line-mode))
  
#+end_src

** Line and column numbers

Configure line and column numbers for relevant modes.

#+begin_src emacs-lisp
  ;;;;; Line and column numbers

  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (add-hook 'text-mode-hook 'display-line-numbers-mode)
  (add-hook 'conf-mode-hook 'display-line-numbers-mode)
  (add-hook 'org-mode-hook (lambda () (display-line-numbers-mode -1)))

  (column-number-mode)

#+end_src

** Smooth scrolling

Smooth scroll line by line.

#+begin_src emacs-lisp
  ;;;;; Smooth scrolling

  (setq redisplay-dont-pause t)
  (setq scroll-margin 1)
  (setq scroll-step 1)
  (setq scroll-conservatively 10000)
  (setq scroll-preserve-screen-position 1)

#+end_src

** Highlight current line

Highlight current line.

#+begin_src emacs-lisp
  ;; highlight current line
  (use-package hl-line
    :hook
    (dired-mode . hl-line-mode)
    (prog-mode . hl-line-mode)
    (special-mode . hl-line-mode)
    :custom
    (hl-line-sticky-flag nil))

#+end_src

** Disable dialog box

Disable UI dialogs and keep keyboard-driven.

#+begin_src emacs-lisp
  (setq use-dialog-box nil)

#+end_src

* Projects and file management

This section is dedicated to manage projects, intended as a collection of closely related files checked into source control, and file management and explorer.

#+begin_src emacs-lisp
  ;;;; Projects and file management

#+end_src

** File manager

=dired= is a great file manager.  Here follow some enhancements.

Base configuration:

#+begin_src emacs-lisp
  ;;;;; File managing with `dired'
  
  ;; base `dired' tweaks
  (use-package dired
    :straight nil				; is builtin
    :defer t
    :commands (dired dired-jump)
    :bind (("C-x j" . dired-jump)
	   :map dired-mode-map ("q" . tr/kill-dired-buffers)) ; TODO: why did I do this?  It seems crazy: dangerous and misleading
    :config
    (setq dired-auto-revert-buffer t)
    (setq dired-dwim-target t)
    (setq dired-recursive-copies 'always)
    (setq dired-recursive-deletes 'top)
    (setq dired-create-destination-dirs 'ask)
    (setq dired-listing-switches "-agho --group-directories-first")
    ;; manage the --dired option of ls
    (when IS-MAC
      (setq dired-use-ls-dired nil))
  
    ;; TODO this is really annoying when doing rm from eshell
    (setq delete-by-moving-to-trash t))
  
#+end_src

=dired= enhancements packages:

#+begin_src emacs-lisp
  ;; use icons in dired
  (use-package all-the-icons-dired
    :if window-system
    :after dired
    :hook (dired-mode . all-the-icons-dired-mode))

  ;; minor mode for hiding dotfiles
  (use-package dired-hide-dotfiles
    :after dired
    ;; TODO FIXME the following binding gets overridden by evil collection (dired-do-hardlink)
    :bind (:map dired-mode-map ("H" . dired-hide-dotfiles-mode)))

  ;; colorize dired
  (use-package diredfl
    :after dired
    :hook (dired-mode . diredfl-mode))

#+end_src

** Projects

Manage projects with builtin =project.el=.

#+begin_src emacs-lisp

  ;; nothing to do?
  
  #+end_src

** Project tree layout

=treemacs= is a tree layout file explorer for projects.

  #+begin_src emacs-lisp
  (use-package treemacs
    :defer t
    :config
    (treemacs-resize-icons 16)
    (add-hook 'treemacs-mode-hook #'hide-mode-line-mode))
  
#+end_src

** Process management

=proced= is an excellent interface for process management.

#+begin_src emacs-lisp
  ;;;;; Process management
  
  (use-package proced
    :straight nil				; is builtin
    :defer t
    :config
    (setq proced-auto-update-interval 5)
    (proced-toggle-auto-update +1))
  
#+end_src

* Editing and behaviour

This section is dedicated to customization and enhancements of editing features, like vim-like
(=evil=) keybindings, text selection utilities, motion commands, parentheses and more.

#+begin_src emacs-lisp
  ;;;; Editing features

#+end_src

** Navigable undo tree

=undo-tree= provides a navigable tree for undoing and redoing.
TODO: add some bindings.

#+begin_src emacs-lisp

  ;; navigable undo/redo tree
  (use-package undo-tree
    :init
    (global-undo-tree-mode +1))

#+end_src

** Vim emulation

Vim emulation inside Emacs with the popular =evil= package.
I really just use vim emulation base navigation commands and then standard Emacs ones, so this
section is rather slim.
=evil-collection= automatically configurate =evil= mode for a bunch of common modes.

#+begin_src emacs-lisp
  ;;;;; Vim emulation

  ;; base evil configuration
  (use-package evil
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-C-u-scroll t)
    (setq evil-want-C-i-jump nil)
    (setq evil-respect-visual-line-mode t)
    (setq evil-undo-system 'undo-tree)
    :config
    (evil-mode +1))

  ;; automatically configure evil for some common modes
  (use-package evil-collection
    :after evil
    :init
    (setq evil-collection-company-use-tng nil) ; i read somewhere that in most cases this is needed for a bug in evil-collection, but don't remember
    :config
    (evil-collection-init))

  ;; integrate with treemacs
  (use-package treemacs-evil
    :after treemacs evil)

  (add-hook 'with-editor-mode-hook 'evil-insert-state)

#+end_src

** Short command confirmation

Typing "yes" or "no" in confirmations is too slow, replace it with "y" or "n".

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)

#+end_src

** Recent files

Easily reopen recent files.

#+begin_src emacs-lisp
  (recentf-mode +1)

#+end_src

Reopen files at the same point.

#+begin_src emacs-lisp
  (save-place-mode +1)

#+end_src

** Auto update buffers

Automatically revert (update) buffers.

#+begin_src emacs-lisp
  ;; auto revert non file buffers
  (setq global-auto-revert-non-file-buffers t)

  ;; auto revert file buffers (when file changes)
  (global-auto-revert-mode 1)

#+end_src

** Share clipboard

Better integration with system clipboard.

#+begin_src emacs-lisp
  (setq save-interprogram-paste-before-kill t)
  
#+end_src

** Text selection and navigation

Add useful text selection and navigation commands.

#+begin_src emacs-lisp
  ;;;;; Text selection and navigation commands

  ;; increases the selected region by semantic units
  (use-package expand-region
    ;; this binding makes sense only in italian keyboard
    :bind ("C-ò" . er/expand-region))

  ;; navigate text with char-based hints
  (use-package avy
    :bind (("C-," . avy-goto-char)))

#+end_src

* Org mode

Lightweight and simple configuration for =org-mode= and =org-roam=.

#+begin_src emacs-lisp
  ;;;; Configure Org mode

#+end_src

** Org and Org Babel

Adjust some defaults, setup =org-babel= languages and setup visual fill column for centering
text with margins for increased readability.

#+begin_src emacs-lisp
  (use-package org
    :straight nil				; use builtin instead of pulling another
    :defer t
    :config
    ;; (org-indent-mode)
    (add-hook 'org-mode-hook 'visual-line-mode)
    ;; (visual-line-mode +1)
    (require 'org-tempo)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (python . t)
       (shell . t)))			; TODO more languages!
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("py" . "src python"))
    (add-to-list 'org-structure-template-alist '("yml" . "src yaml"))
    (add-to-list 'org-structure-template-alist '("json" . "src json"))
    (setq org-src-fontify-natively t)
    (setq org-src-tab-acts-natively t)
    (setq org-edit-src-content-indentation 2)
    (setq org-hide-block-startup nil)
    (setq org-src-preserve-indentation nil)
    (setq org-hide-leading-stars t)
    (setq org-adapt-indentation nil)
    (setq org-startup-folded 'content)
    (setq org-cycle-separator-lines 2)
    (setq org-return-follows-link t)	; TODO some problems with evil
    (setq org-startup-truncated nil)
    (setq org-startup-with-inline-images t))

  #+end_src
  
Visual fill column: center text with margins, improving readability and look.

  #+begin_src emacs-lisp
  (defun tr/org-mode-visual-fill ()
    "Visual fill configuration for org mode."
    (setq visual-fill-column-width 100
	  visual-fill-column-center-text t)
    (visual-fill-column-mode 1))
  
  (use-package visual-fill-column
    :after org
    :hook (org-mode . tr/org-mode-visual-fill))
  
#+end_src

** Auto tangle

Auto tangle on save.

#+begin_src emacs-lisp
  ;;;;; Auto tangle on save
  
  (defun tr/org-auto-tangle ()
    "Set hook for auto tangling org files on save."
      (let ((org-confirm-babel-evaluate nil))
	(org-babel-tangle)))
  
  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'tr/org-auto-tangle 0 t)))
  
#+end_src

** Org Roam

#+begin_src emacs-lisp
  (use-package org-roam
    :init
    (setq org-roam-v2-ack t)
    :bind (("C-c n l" . org-roam-buffer-toggle)
	   ("C-c n f" . org-roam-node-find)
	   ("C-c n i" . org-roam-node-insert))
    :config
    (setq org-roam-directory "~/RoamNotes")
    (org-roam-setup))

#+end_src

* Windows and buffers management

Window management can be kind of weird in Emacs.  It's not rare that windows are created when we
don't want to, and demolish a careful placed window setting.
Also buffer list can be really cluttered, especially in long running sessions.
This section is dedicated to (try) to fix some of these issues.

#+begin_src emacs-lisp
  ;;;; Windows and buffer management

#+end_src

** Optimize window placement

Or at least try to.  =shackle= is a good starting point: it allows defining rules for how windows are displayed.

TODO: more shackle rules are needed

#+begin_src emacs-lisp
  ;; define window placement rules
  (use-package shackle
    :init
    (shackle-mode +1)
    :config
    (setq shackle-rules
	  ;; TODO add here more rules
	  '((compilation-mode :noselect t)
	    (help-mode    :popup t :select t :align bottom :size 0.33)
	    (helpful-mode :popup t :select t :align bottom :size 0.33)
	    ("\\*Warnings\\*" :regexp t :noselect t))
	  shackle-default-rule '(:noselect t)))
  
#+end_src

** Popup buffers

Some buffers have an ephemeral nature and are not needed on screen all the time.
The =popper= package helps in treating them like "popups".

#+begin_src emacs-lisp
  ;; define and manage popup buffers
  (use-package popper
    :defer t
    ;; this bindings make sense only in italian keyboard
    :bind (("C-è"   . popper-toggle-latest)
	   ("M-è"   . popper-cycle)
	   ("C-M-è" . popper-toggle-type))
    :config
    (setq popper-reference-buffers	; list of buffers treated as popups
	  '("\\*Messages\\*"
	    "Output\\*$"
	    help-mode
	    helpful-mode
	    compilation-mode))
    (setq popper-mode-line '(:eval (propertize " P " 'face 'mode-line-emphasis)))
    (setq popper-display-control nil)	; display control is actually performed by shackle
    (popper-mode +1))

#+end_src

** Window navigation

=ace-window= is like =avy= but for windows and can avoid window ciclying with =C-x o=.

#+begin_src emacs-lisp
  ;; great window navigation and selection command
  (use-package ace-window
    :bind (("M-o" . ace-window)))

#+end_src

** Buffer helpers

Some helpers for dealing with buffers.

#+begin_src emacs-lisp
  ;;;;; buffer helpers

  ;; use `ibuffer' instead of buffer list
  (global-set-key (kbd "C-x C-b") 'ibuffer)

  (defun tr/kill-other-buffers ()
    "Kill all other buffers."
    (interactive)
    (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))

  (defun tr/kill-mode-buffers (mode)
    "Kill all buffers with major mode MODE."
    (interactive
     (list
      (intern
       (completing-read
	"Mode: "
	(delete-dups
	 (mapcar
	  (lambda (buffer)
	    (buffer-local-value 'major-mode buffer))
	  (buffer-list)))))))
    (mapc (lambda (buffer)
	    (when (eq mode (buffer-local-value 'major-mode buffer))
	      (kill-buffer buffer)))
	  (buffer-list))
    (message "Killed buffers with major mode %s" mode))

  (defun tr/kill-dired-buffers ()
    "Kill all Dired buffers."
    (interactive)
    (tr/kill-mode-buffers 'dired-mode))

  (defun tr/kill-help-buffers ()
    "Kill all help buffers."
    (interactive)
    (tr/kill-mode-buffers 'help-mode)
    (tr/kill-mode-buffers 'helpful-mode))

#+end_src

* Terminals

This section is dedicated to enhance Emacs terminals, with special interest in =eshell=.

#+begin_src emacs-lisp
  ;;;; Terminals

#+end_src

** Term

=term= is a terminal emulator written in Emacs Lisp.  It's very slow.
Since I rarely use it, just set proper colors:

#+begin_src emacs-lisp
  ;;;;; term

  (use-package eterm-256color
    :after term
    :hook (term-mode . eterm-256color-mode))

#+end_src

** Vterm

=vterm= is a fully-fledged terminal emulator based on the C library =libvterm=.
As such, it is compiled and fast. 

#+begin_src emacs-lisp
  ;;;;; vterm
  
  (use-package vterm
    :defer t
    :commands vterm
    :config
    (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")
    (setq vterm-max-scrollback 10000)
    (setq vterm-kill-buffer-on-exit t))
  
  ;; TODO try vterm-toggle: https://github.com/jixiuf/vterm-toggle
  
#+end_src

** Eshell

Eshell is a very interesting shell written entirely in Emacs Lisp.  Many common Unix programs are
totally rewritten in Emacs Lisp.  Eshell is not a terminal emulator, and it does not send commands
to an external interpreter (like bash).  Everything remains inside Emacs, and Elisp expressions can
be evaulated as well.

Configuration is done manually instead of using =use-package= to get sure that everything is loaded
in the correct order, taking advantage of the modular structure of eshell.

#+begin_src emacs-lisp
  ;;;;; eshell

#+end_src

*** Prompt

Set a good-looking prompt displaying useful information, like pwd and git branch.

This part is heavily inspired (or even copied!) from Doom Emacs and daviwil config.

#+begin_src emacs-lisp
    ;;;;;; eshell prompt
  
  (with-eval-after-load 'em-prompt
    (defun tr/prompt-path ()
      "Path (pwd) that will be displayed in prompt."
      (let* ((pwd (eshell/pwd)))
	(if (equal pwd "~")
	    pwd
	  ;; (abbreviate-file-name (shrink-path-file-pwd)))))
	  (abbreviate-file-name pwd))))
  
    (defun tr/eshell-prompt ()
      "The eshell prompt."
      (let ((current-branch (when (fboundp 'magit-get-current-branch)
			      (magit-get-current-branch))))
	(concat
	 (if (bobp) "" "\n")
	 (propertize user-login-name 'face `(:foreground "#62aeed"))
	 (propertize " • " 'face `(:foreground "white"))
	 (propertize (tr/prompt-path) 'face `(:foreground "#82cfd3"))
	 (when current-branch
	   (concat
	    (propertize " • " 'face `(:foreground "white"))
	    (propertize (concat " " current-branch) 'face `(:foreground "#c475f0"))))
	 (propertize " • " 'face `(:foreground "white"))
	 (propertize (format-time-string "%H:%M:%S") 'face `(:foreground "#5a5b7f"))
	 (let ((user-prompt
		(if (= (user-uid) 0) "\n#" "\nλ")))
	   (propertize user-prompt 'face (if (zerop eshell-last-command-status) 'success 'error)))
	 " ")))
  
    (setq eshell-prompt-function #'tr/eshell-prompt
	  eshell-prompt-regexp "^.*λ "
	  eshell-highlight-prompt t))
  
#+end_src

*** Banner

The banner is the welcome message in eshell.

#+begin_src emacs-lisp
  ;;;;;; eshell banner
  
  (with-eval-after-load 'em-banner
    (setq eshell-banner-message
	  '(format "%s %s\n\n"
		   (propertize (format " %s " (string-trim (buffer-name)))
			       'face 'mode-line-highlight)
		   (propertize (current-time-string)
			       'face 'font-lock-keyword-face))))
  
#+end_src

*** Keys and aliases

Optimize evil mode in eshell and add useful aliases.

#+begin_src emacs-lisp
  ;;;;;; eshell keybindings and aliases

  (with-eval-after-load 'em-alias
    (evil-collection-eshell-setup)
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "C-R") 'consult-history)
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "C-l") 'eshell/clear)
    (evil-normalize-keymaps)

    (dolist
	(alias
	 '(("q"     "exit")
	   ("f"     "find-file $1")
	   ("ff"    "find-file $1")
	   ("d"     "dired $1")
	   ("pd"    "proced $1")
	   ("rg"    "rg --color=always $*")
	   ("l"     "ls -lh $*")
	   ("ll"    "ls -lah $*")
	   ("git"   "git --no-pager $*")
	   ("gg"    "magit-status")
	   ("clear" "clear-scrollback")
	   ("u"     "eshell-up $1")))	; see section below for `eshell-up' command and package
      (add-to-list 'eshell-command-aliases-list alias))
    (eshell-write-aliases-list))

#+end_src

*** Colors

Colors are not so easy to setup correctly in eshell.  Here is what I found in some online resource (ambrevar, daviwil, Doom Emacs).

#+begin_src emacs-lisp
  ;;;;;; eshell colors

  (use-package xterm-color
    ;; let's rely only on xterm-color autoloads
    :defer t)

  (with-eval-after-load 'eshell 		; don't know if there is a specific module
    (delq 'eshell-handle-ansi-color eshell-output-filter-functions)

    (push 'xterm-color-filter eshell-preoutput-filter-functions)
    (add-hook 'eshell-before-prompt-hook
	      (lambda ()
		(setq xterm-color-preserve-properties t)))

    (setq eshell-term-name "xterm-256color")

    ;; We want to use xterm-256color when running interactive commands
    ;; in eshell but not during other times when we might be launching
    ;; a shell command to gather its output (from daviwil conf)
    (add-hook 'eshell-pre-command-hook
	      #'(lambda () (setenv "TERM" "xterm-256color")))
    (add-hook 'eshell-post-command-hook
	      #'(lambda () (setenv "TERM" "dumb"))))

#+end_src

*** History

Configure eshell history.

#+begin_src emacs-lisp
  ;;;;;; eshell history

  (with-eval-after-load 'em-hist
    (add-hook 'eshell-pre-command-hook #'eshell-save-some-history)
    (setq eshell-history-size 10000
	  eshell-history-ignoredups t
	  eshell-input-filter #'eshell-input-filter-initial-space
	  ;; don't record command in history if prefixed with whitespace
	  eshell-input-filter #'eshell-input-filter-initial-space)
    (eshell-hist-initialize))

#+end_src

*** Visual commands

Configure visual commands.  Visual commands are commands that need a proper terminal emulator,
like the ones based on curses/ncurses, and they are opened in a term buffer instead.

#+begin_src emacs-lisp
  ;;;;;; eshell visual commands

  (with-eval-after-load 'em-term
    (dolist (cmd '("htop" "vim" "nvim"))
      (add-to-list 'eshell-visual-commands cmd)))

#+end_src

*** Generic configuration and eshell defaults

Set some eshell defaults and generic configuration.

#+begin_src emacs-lisp
  ;;;;;; eshell defaults and generic conf

  (with-eval-after-load 'eshell
    (setenv "PAGER" "cat")
    ;; Truncate buffer for performance
    (add-to-list 'eshell-output-filter-functions #'eshell-truncate-buffer)
    ;; use TRAMP
    (add-to-list 'eshell-modules-list 'eshell-tramp)
    ;; Enable autopairing in eshell
    (add-hook 'eshell-mode-hook #'smartparens-mode)

    (setq password-cache t
	  password-cache-expiry 3600)

    (setq eshell-buffer-maximum-lines 10000
	  eshell-scroll-to-bottom-on-input 'all
	  eshell-scroll-to-bottom-on-output 'all
	  eshell-kill-processes-on-exit t
	  eshell-glob-case-insensitive t
	  eshell-error-if-no-glob t))

#+end_src

*** Navigation

Enhance and speedup directory navigation in eshell.

#+begin_src emacs-lisp
  ;;;;;; eshell navigation

#+end_src

=eshell-up= provides a useful command for quickly navigating to a specific parent directory in eshell without having to repeatedly typing =cd ..=.
You can just go up of one level ore specify a part of the path for quick navigation.

https://github.com/peterwvj/eshell-up

#+begin_src emacs-lisp
  (use-package eshell-up
    :after eshell
    :commands eshell-up eshell-up-peek)

#+end_src

=eshell-z= is an Emacs port of z.

https://github.com/xuchunyang/eshell-z

#+begin_src emacs-lisp
  (use-package eshell-z
    :after eshell
    :commands eshell-z
    :config
    ;; Use zsh's db if it exists, otherwise, store it in eshell directory
    (unless (file-exists-p eshell-z-freq-dir-hash-table-file-name)
      (setq eshell-z-freq-dir-hash-table-file-name
	    (expand-file-name "z" eshell-directory-name))))

#+end_src

*** Help, highlighting and completions

Configure help, highlighting and completions.

#+begin_src emacs-lisp
  ;;;;;; eshell help, highlighting, suggestions, completions

  (use-package esh-help
    :after eshell
    :config (setup-esh-help-eldoc))

  (use-package eshell-syntax-highlighting
    :after eshell
    :hook (eshell-mode . eshell-syntax-highlighting-mode))

  (use-package esh-autosuggest
    :after eshell
    :hook (eshell-mode . esh-autosuggest-mode)
    :config
    (setq esh-autosuggest-delay 0.5))

#+end_src

*** Eshell popup

In addition to a normal eshell buffer, sometimes is useful to be able to toggle an eshell popup
under the current window just to run a couple of quick commands.

#+begin_src emacs-lisp
  ;; TODO: remove this, drop eshell-toggle and write simple popup with shackle and popper
  (defun tr/eshell-toggle-init-eshell (dir)
    "Init eshell in DIR for `eshell-toggle'."
    (let* ((buffer-name (format "*eshell-popup:%s*"
				(file-name-nondirectory
				 (directory-file-name default-directory))))
	   (eshell-buffer (get-buffer-create buffer-name)))
      (with-current-buffer (switch-to-buffer eshell-buffer)
	(if (eq major-mode 'eshell-mode)
	    (run-hooks 'eshell-mode-hook)
	  (eshell-mode))
	(hide-mode-line-mode 1))
      (pop-to-buffer eshell-buffer)))

  (use-package eshell-toggle
    :bind ("C-M-'" . eshell-toggle)
    :custom				; TODO don't really like custom
    (eshell-toggle-size-fraction 3)
    (eshell-toggle-use-git-root t)
    (eshell-toggle-run-command nil)
    (eshell-toggle-init-function #'tr/eshell-toggle-init-eshell))

#+end_src

* Development

This section is dedicated to enhance the development environment.

#+begin_src emacs-lisp
  ;;;; Development

#+end_src

** Version control

Magit is a really superlative git interface and works greatly out the box without any furhter customization.

#+begin_src emacs-lisp
  ;;;;; Version control

  (use-package magit
    :commands magit-status magit-get-current-branch
    :init
    ;; just mute this annoying message
    (setq magit-no-message '("Turning on magit-auto-revert-mode...")))

  ;; integrate with treemacs
  (use-package treemacs-magit
    :after treemacs magit)

  ;; highlight uncommitted changes (git gutters)
  (use-package diff-hl
    :hook
    ((dired-mode . diff-hl-dired-mode-unless-remote)
     (magit-post-refresh . diff-hl-magit-post-refresh)
     (prog-mode . diff-hl-mode)
     (prog-mode . diff-hl-margin-mode))
    :config
    (add-hook 'magit-pre-refresh-hook 'diff-hl-magit-pre-refresh)
    (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))

#+end_src

** Parentheses

Configure parentheses and delimiters.

#+begin_src emacs-lisp
  ;;;;; Configure parentheses

  ;; highlight mathing parentesis
  (show-paren-mode 1)

  ;; auto close parentheses in prog mode
  (use-package smartparens
    :hook
    (prog-mode . smartparens-mode)
    (inferior-emacs-lisp-mode . smartparens-mode)
    :config
    (require 'smartparens-config))

  ;; highlight matching delimiters with rainbow colors
  (use-package rainbow-delimiters
    :hook
    (prog-mode . rainbow-delimiters-mode)
    (inferior-emacs-lisp-mode . rainbow-delimiters-mode))
#+end_src

** Syntax checking

Setup syntax checking with the builtin =flycheck= package.  Integration with =consult= is provided too.

#+begin_src emacs-lisp
  ;;;;; Syntax checking

  (use-package flycheck
    :hook (prog-mode . flycheck-mode))

  (use-package flycheck-inline
    :hook
    (flycheck-mode . flycheck-inline-mode))

  (use-package consult-flycheck
    :requires (consult flycheck)
    :after (consult flycheck)
    :bind (:map flycheck-command-map
		("!" . consult-flycheck)))

#+end_src

** Compilation buffer

Enhance compilation buffer.

#+begin_src emacs-lisp
  ;;;;; Enhance compilation buffer

  (with-eval-after-load 'compilation-mode (require 'ansi-color))

  ;; colorize compilation buffer
  (defun tr/colorize-compilation-buffer ()
    "Support ANSI colors in compilation buffer."
    (when (eq major-mode 'compilation-mode)
      (ansi-color-apply-on-region compilation-filter-start (point-max))))

  (add-hook 'compilation-filter-hook #'tr/colorize-compilation-buffer)

  ;; follow output with scroll in compilation buffer
  (setq compilation-scroll-output t)

#+end_src

** Indentation

Indentation is always a delicate matter.

#+begin_src emacs-lisp
  ;;;;; Indentation

#+end_src

Highlight indent guides for some modes.

#+begin_src emacs-lisp
  ;; show indent guides in some modes
  (use-package highlight-indent-guides
    :hook
    ((python-mode yaml-mode) . highlight-indent-guides-mode)
    ;; TODO add some more modes.
    :custom
    (highlight-indent-guides-method 'character))

#+end_src

Aggressively indent as you type.

#+begin_src emacs-lisp
  ;; aggressively indent as you type
  (use-package aggressive-indent
    :hook
    (emacs-lisp-mode . aggressive-indent-mode)
    (lisp-mode . aggressive-indent-mode)
    (scheme-mode . aggressive-indent-mode)
    ;; TODO add some more modes.
    :custom
    (aggressive-indent-comments-too t)
    :config
    (add-to-list 'aggressive-indent-protected-commands 'comment-dwim))

#+end_src

** LSP mode

Language Server Protocol can help unifying the configurations for many language.  It's practically
a frontend for a server that has to be up and running in backgroung.
Many language servers can be installed automatically from Emacs after a prompt.
If not, refer to the documentation: https://emacs-lsp.github.io/lsp-mode/page/languages

DAP mode (Debug Adapter Protocol) is the LSP counterpart for debugging.

TODO: apparently does not work with corfu

#+begin_src emacs-lisp
  ;;;;; lsp and dap mode

  (use-package lsp-mode
    :defer t
    :commands (lsp-mode lsp-deferred)
    :init
    (setq lsp-keymap-prefix "M-RET")
    :config
    (setq lsp-enable-which-key-integration t)
    (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
    (lsp-headerline-breadcrumb-mode))

  (use-package dap-mode
    :defer t
    :after lsp-mode
    :config
    (dap-auto-configure-mode))

#+end_src

** Languages

Language specific configuration.

#+begin_src emacs-lisp
  ;;;;; Languages

#+end_src

*** Java

#+begin_src emacs-lisp
  ;;;;;; Java
  
  ;; TODO parse lombok version from pom
  (defvar lombok-jar-path
    (expand-file-name
     "~/.m2/repository/org/projectlombok/lombok/1.18.10/lombok-1.18.10.jar"))
  
  (use-package lsp-java
    :defer t
    :hook (java-mode . lsp)
    :config
    (add-hook 'java-mode-hook 'lsp)
    ;; TODO check in pom if lombok is a dependency
    ;;  or better search in background if lombok is in classpath
    (when (file-exists-p lombok-jar-path)
      (setq lsp-java-vmargs `("-XX:+UseStringDeduplication"
			      ,(concat "-javaagent:" lombok-jar-path)
			      ,(concat "-Xbootclasspath/a:" lombok-jar-path)
			      "--add-modules=ALL-SYSTEM"))))
  
  (use-package dap-java
    :defer t
    :straight nil)
  
#+end_src

*** Groovy

#+begin_src emacs-lisp
  ;;;;;; Groovy
  
  (use-package groovy-mode
    :mode "\\.groovy\\'"
    :hook (groovy-mode . lsp-deferred))
  
#+end_src

*** Clojure

#+begin_src emacs-lisp
  ;;;;;; Clojure
  
  (use-package clojure-mode
    :mode "\\.clj\\'"
    :hook (clojure-mode . lsp-deferred))
  
  (use-package cider
    :defer t)

#+end_src

*** Node.js

#+begin_src emacs-lisp
  ;;;;;; Node.js

  (use-package typescript-mode
    :mode "\\.ts\\'"
    :hook (typescript-mode . lsp-deferred)
    :config
    (require 'dap-node)
    (dap-node-setup)
    (setq typescript-indent-level 2))

  (use-package npm-mode
    :after typescript-mode)		; TODO js, react

  (use-package nvm
    :after typescript-mode		; TODO js, react
    :commands (nvm-use nvm-use-for nvm-use-for-buffer))

  ;; TODO: this is global but should be buffer local
  (defun tr/nvm-use (version)
    "Interactive wrapper of `nvm-use'.  Choose node VERSION amongst installed versions."
    (interactive
     (list
      (completing-read "Version: " (mapcar 'car (nvm--installed-versions)))))
    (nvm-use version)
    (message "Using node version %s" version))

  (require 's)
  (require 'f)

  ;; TODO: continue prompt of node version in case of missing .nvmrc
  ;; TODO: this probably sucks
  (defun tr/nvm-project ()
    "Set up project node interpreter with nvm.
  If .nvmrc is present in project root, it will be used.  Otherwise node
  version will be prompted."
    (interactive)
    (when (file-exists-p (expand-file-name "package.json" (project-root (project-current))))
      (let ((nvmrc (expand-file-name ".nvmrc" (project-root (project-current)))))
	(if (file-exists-p nvmrc)
	    (let ((version (s-trim (f-read nvmrc))))
	      (nvm-use version)
	      (message "Using node version %s" version))
	  (call-interactively 'tr/nvm-use)))))

#+end_src

*** Python

#+begin_src emacs-lisp
  ;;;;;; Python

  (use-package elpy
    :defer t
    :init
    (advice-add 'python-mode :before 'elpy-enable)
    (setq python-shell-interpreter "python3.8"
	  python-shell-interpreter-args "-i")
    :custom
    (elpy-get-info-from-shell t)
    (elpy-shell-echo-input nil)
    (elpy-syntax-check-command "pyflakes")
    :config
    (elpy-shell-set-local-shell (elpy-project-root))
    (when (load "flycheck" t t)
      (message "loading flycheck for elpy")
      (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
      (add-hook 'elpy-mode-hook 'flycheck-mode)))

#+end_src

*** Rust

#+begin_src emacs-lisp
  ;;;;;; Rust
  
  (use-package rust-mode
    :mode "\\.rs\\'"
    :bind
    (:map rust-mode-map
	  (("C-c C-t" . racer-describe)
	   ("TAB" .  company-indent-or-complete-common)))
    :config
    (progn
      (use-package flycheck-rust)
      (use-package cargo
	:hook (rust-mode . cargo-minor-mode))
      (use-package racer
	:hook (rust-mode . racer-mode)
	:config
	(progn
	  (add-hook 'racer-mode-hook #'company-mode)
	  (add-hook 'racer-mode-hook #'eldoc-mode)))
  
      (add-hook 'rust-mode-hook 'flycheck-mode)
      (add-hook 'flycheck-mode-hook 'flycheck-rust-setup)
  
      ;; format rust buffers on save using rustfmt
      (add-hook 'before-save-hook
		(lambda ()
		  (when (eq major-mode 'rust-mode)
		    (rust-format-buffer))))))
  
#+end_src

*** C#

Sadly, sometimes C# happens.

#+begin_src emacs-lisp
  ;;;;;; C#
  
  (use-package csharp-mode
    :mode "\\.cs\\'"
    :config
    (add-hook 'csharp-mode-hook 'lsp))
  
#+end_src

*** LaTeX

Add a preview pane of the current edited LaTeX buffer.

#+begin_src emacs-lisp
  ;;;;;; LaTeX
  
  ;; add a preview pane of the current edited LaTeX buffer.
  (use-package latex-preview-pane
    :hook (latex-mode . latex-preview-pane-mode))
  
#+end_src

*** Configuration and markup

#+begin_src emacs-lisp
  ;;;;;; configuration and markup

  (use-package dockerfile-mode
    :mode "Dockerfile")

  (use-package markdown-mode
    :mode ("\\.md\\'"
	   "\\.mkd\\'"
	   "\\.markdown\\'")
    :commands (markdown-mode gfm-mode)
    :init
    (setq mardown-command "multimarkdown"))

  (use-package yaml-mode
    :mode "\\.ya?ml\\'")

  (use-package toml-mode
    :mode "\\.toml\\'")

  (use-package csv-mode
    :mode "\\.csv\\'")

  (use-package terraform-mode
    :mode "\\.tf\\'")
  
#+end_src

* Footer

#+begin_src emacs-lisp
  ;;; init.el ends here
#+end_src
